<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>链接</title>


  <!-- link标签类型主要根据rel属性的值去判断 -->

  <!-- 1) 超链接型link ---不会主动下载href的资源 -->
  <!-- 1.1) 这个标签提示页面它的主URL，在网站中常常有多个URL指向同一页面的情况，搜索引擎访问这类页面时会 去掉重复的页面，这个link会提示搜索引擎保留哪一个URL。 -->
  <!-- canonical）adj. 真经的；经典的；准确的；权威的；公认的... -->
  <!-- 告诉搜索引擎，当前页面的主url是哪一个 -->
  <link rel="canonical" href="...">

  <!-- 1.2) 这个标签提示页面它的变形形式，这个所谓的变形可能是当前页面内容的不同格式、不同语言或者为不同的 设备设计的版本，这种link通常也是提供给搜索引擎来使用的。 -->
  <!-- 当前页面有其他替代版本，提示搜索引擎用的，常服务于rss订阅以及浏览器插件 -->
  <link rel="alternate" href="...">
  <link rel="alternate" type="application/rss+xml" title="RSS" href="...">

  <!-- 1.3)  -->
  <link rel="next" href="...">
  <!-- 1.4)  -->
  <link rel="prev" href="...">


  <!-- 2.)  外部资源型link-->
  <!-- 2.1)  icon型link中的 图标地址默认会被浏览器下载和使用。-->
  <!-- 如果没有指定这样的link，多数浏览器会使用域名根目录下的favicon.ico，即使它并不存在，所以从性能的 角度考虑，建议一定要保证页面中有icon型的link。 -->
  <!-- <link rel="icon" sizes="any" href="//img1.bdstatic.com/static/common/img/icon_cf1b905.png"> -->

  <!-- 2.2) 预处理类link -->
  <!-- 导航到一个网站需要经过dns查询域名、建立连接、传输数据、加载进内存和渲染等一系列的 步骤。 -->
  <!-- 预处理类link标签就是允许我们控制浏览器，提前针对一些资源去做这些操作，以提高性能 -->
  <!-- 
    dns-prefetch型link 提前对一个域名做dns查询，这样的link里面的href实际上只有域名有意义。 
    preconnect型link 提前对一个服务器建立tcp连接。 
    prefetch型link 提前取href指定的url的内容。
    preload型link 提前加载href指定的url。 
    prerender型link 提前渲染href指定的url。 
  -->


  <!-- 2.3) modulepreload型link-->
  <!-- modulepreload型link的作用是预先加载一个JavaScript的模块。这可以保证JS模块不必等到执行时才加载。 这里的所谓加载，是指完成下载并放入内存，并不会执行对应的JavaScript。 -->
  <!-- <link rel="modulepreload" href="app.js">
  <link rel="modulepreload" href="helpers.js">
  <link rel="modulepreload" href="irc.js">
  <link rel="modulepreload" href="fog-machine.js">
  <script type="module" src="app.js"></script> -->
  <!-- 这个例子来自HTML标准，我们假设app.js中有 import “irc” 和 import “fog-machine”, 而 irc.js中有 import “helpers”。这段代码使用moduleload型link来预加载了四个js模块。 -->
  <!-- 但是我们通过加入对四个JS文件的link标签，使得四个JS文件有机会被并行地下载，这样提高了性能。 -->


  <!-- 2.4) stylesheet 样式引入-->
  <!-- 从一个CSS文件创建一个样式表 -->
  <!-- 这里type属性可以没有，如果有，必须是"text/css"才会生效 -->
  <!-- <link rel="stylesheet" href="xxx.css" type="text/css"> -->

  <!-- 2.5) pingback型link-->
  <!-- 当前页面被引用的时候，会向pinkback的url发送一个消息 -->
  <!-- pingback 引用通告处理当前文档被引用情况的服务器地址 -->
  <!-- 这样的link表示本网页被引用时，应该使用的pingback地址，这个机制是一份独立的标准，遵守pingback协议的网站在引用本页面时，会向这个pingback url发送一个消息。 -->
  <!-- <link rel="pingback" href="xxx"> -->

</head>

<body>

  <h1>a链接</h1>
  <!-- <a href="https://www.baidu.com/" rel="noopener ">此链接打开的网页无法使用opener来获得当前页面的窗口；</a> -->
  <!-- window.opener//null -->
  <br>

  <!-- <a href="https://www.baidu.com/" rel="noreferrer ">此链接打开的网页无法使用referrer来获得当前页面的url； </a> -->

  <br>

  <!-- <a href="https://www.baidu.com/" rel="opener ">打开的网页可以使用window.opener来访问当前页面的window对象，这是a标签的默认行为。 </a> -->
  <a href="https://www.baidu.com/">aa</a>


  <h1>area 链接</h1>
  <!-- area必须跟img和map标签配合使用。使用示例如下（例子来自html标准）。 -->
  <!-- <p> Please select a shape: </p>
    <img src="0.jpg" usemap="#shapes" alt="Four ...">
    
    <map name="shapes"> 
      <area shape=rect coords="50,50,100,100"> 
      <area shape=rect coords="25,25,125,125" href="red.html" alt="Red box.">
      <area shape=circle coords="200,75,50" href="green.html" alt="Green circle."> 
      <area shape=poly coords="325,25,262,125,388,125" href="blue.html"  alt="Blue triangle.">
    </map>  -->

   
    <a href=" https://www.runoob.com/try/try.php?filename=tryhtml_areamap">w3school示例</a>
</body>

</html>